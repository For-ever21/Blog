> 将其操作数当做32位的比特序列，操作数字的二进制形式，但返回值依然是标准的js数值

所有的按位操作符的操作数都会被转成补码（two's complement）形式的有符号32位整数

例如 整数 314 的二进制编码

`00000000000000000000000100111010`

下面 ~314 为它的反码

`11111111111111111111111011000101`

最后，下面编码 -314，即 314 的反码 再加 1：

`11111111111111111111111011000110`

## 按位逻辑操作符

* 按位与（&）
> 将任一数值 x 与 0 执行按位与操作，其结果都为 0。将任一数值 x 与 -1 执行按位与操作，其结果都为 x。

* 按位或（|）
> 将任一数值 x 与 0 进行按位或操作，其结果都是 x。将任一数值 x 与 -1 进行按位或操作，其结果都为 -1。

* 按位异或（^）
> 将任一数值 x 与 0 进行异或操作，其结果为 x。将任一数值 x 与 -1 进行异或操作，其结果为 ~x

* 按位非（~）
> 也就是反码, 负值 就是反码 + 1

```js
9(base 10) =          1001(base 2);
15(base 10) =        01111(base 2);
---------------------------
9 & 15(base 10) =    01001(base 2) = 9(base 10);
9 | 15(base 10) =    01111(base 2) = 15(base 10);
9 ^ 15(base 10) =    00110(base 2) = 6(base 10);
~15(base 10) =       10000(base 2) = -16(base 10);
```

## 按位移动操作符

* 左移 <<
> 该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。
注：在数字X上左移相当于 `x*2`的`y`次方

* 有符号右移 >>
> 左侧填充的数，没有变化，因此称为`符号传播`

* 无符号右移 >>>
> 左侧用`0`填充,则会导致 负数情况结果变化
> 对于 非负数，返回的结果和`有符号右移`是一样的

```js
9(base 10) =  000001001;
-9(base 10) = 111110111;
9 << 3 (base 10) = 001001000 = 72 (base 10) // 9 * 2的3次方
9 >> 3 (base 10) = 000000001 = 1 (base 10) // 
-9 >> 3 (base 10)= 111111110 = -2 (base 10)
```